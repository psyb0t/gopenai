package gopenai

import (
	"encoding/json"
	"fmt"
	"net/http"
)

const completionsAPIEndpoint = "/completions"

// LogProbabilities represents the log-probabilities of generated tokens
// and the text offsets of each token in the prompt.
type LogProbabilities struct {
	// TextOffset represents the text offsets of each token in the prompt.
	TextOffset []int `json:"text_offset"`
	// TokenLogprobs is an array of log-probabilities of each generated token.
	TokenLogprobs []float64 `json:"token_logprobs"`
	// Tokens is an array of generated tokens.
	Tokens []string `json:"tokens"`
	// TopLogprobs is an array of dictionaries, each containing the
	// log-probabilities of the top-k completions for each position in the prompt.
	TopLogprobs []map[string]float64 `json:"top_logprobs"`
}

// CompletionChoice represents a single completion for a given prompt.
type CompletionChoice struct {
	// Text is the generated completion.
	Text string `json:"text"`
	// Index is the index of the completion in the list of choices.
	Index int `json:"index"`
	// Logprobs is the LogProbabilities struct for the completion.
	Logprobs LogProbabilities `json:"logprobs"`
	// FinishReason is the reason why the completion was
	// stopped, such as "max_tokens".
	FinishReason string `json:"finish_reason"`
}

// Completion represents the completion of a prompt generated by the API.
type Completion struct {
	// ID is the ID of the completion.
	ID string `json:"id"`
	// Created is the UNIX timestamp of when the completion was created.
	Created int `json:"created"`
	// Model is the ID of the model used to generate the completion.
	Model string `json:"model"`
	// Choices is a list of CompletionChoice structs representing
	// the different completions generated for the prompt.
	Choices []CompletionChoice `json:"choices"`
	// Usage is the token usage of the model.
	Usage TokenUsage `json:"usage"`
}

// CompletionParams represents the parameters for
// generating a completion with the API.
type CompletionParams struct {
	// Model is the ID of the model to use for the completion.
	Model string `json:"model"`
	// Prompt is the prompt to generate a completion for.
	Prompt string `json:"prompt,omitempty"`
	// Suffix is the suffix to add to the end of the prompt
	// when generating a completion.
	Suffix string `json:"suffix,omitempty"`
	// MaxTokens is the maximum number of tokens to generate in the completion.
	MaxTokens int `json:"max_tokens,omitempty"`
	// Temperature is a value controlling the randomness of the
	// generated tokens, with higher values leading to more random completions.
	Temperature float64 `json:"temperature,omitempty"`
	// TopP is a value between 0 and 1 controlling the amount of diversity in
	// the generated completions, with higher values leading
	// to less diverse completions.
	TopP float64 `json:"top_p,omitempty"`
	// N is the number of completions to generate for the prompt.
	N int `json:"n,omitempty"`
	// Logprobs specifies if the log probabilities for each token in
	// the completion should be returned.
	Logprobs int `json:"logprobs,omitempty"`
	// Echo specifies if the prompt should be repeated in the returned text.
	Echo bool `json:"echo,omitempty"`
	// Stop is a string that, if encountered in the generated text,
	// will cause completion to stop.
	Stop string `json:"stop,omitempty"`
	// PresencePenalty is the penalty applied to log probabilities of
	// tokens that are not present in the prompt.
	PresencePenalty float64 `json:"presence_penalty,omitempty"`
	// FrequencyPenalty is the penalty applied to log probabilities based
	// on the token's frequency in the training data.
	FrequencyPenalty float64 `json:"frequency_penalty,omitempty"`
	// BestOf specifies the number of best completions to keep, out
	// of all the generated completions.
	BestOf int `json:"best_of,omitempty"`
	// User is a string that can be used to specify a user id.
	User string `json:"user,omitempty"`
}

// CompletionsAPI is an interface for creating completions.
type CompletionsAPI interface {
	// Create generates a new completion based on the given
	// CompletionParams and returns it as a Completion object.
	Create(CompletionParams) (Completion, error)
}

type completionsAPI struct {
	c client
}

func (api completionsAPI) Create(params CompletionParams) (Completion, error) {
	url := fmt.Sprintf("%s%s", baseURL, completionsAPIEndpoint)
	r, err := api.c.getJSONRequestResponse(url, http.MethodPost, params)
	if err != nil {
		return Completion{}, err
	}

	var response Completion
	if err := json.Unmarshal(r, &response); err != nil {
		return Completion{}, err
	}

	return response, nil
}
